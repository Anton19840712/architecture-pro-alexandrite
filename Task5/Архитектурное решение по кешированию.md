# Архитектурное решение по кешированию

---

## 1. Мотивация

### Текущая проблема

Операторы MES жалуются на низкую скорость работы со страницей списка заказов:
- Дашборд MES долго прогружается
- Фильтр по статусам и пагинация не решили проблему
- Операторам важно видеть самые новые заказы быстро (от этого зависит их вознаграждение)

**Техническая причина:**
- Каждый запрос списка заказов идет напрямую в PostgreSQL
- При росте количества заказов время ответа увеличивается
- Один инстанс БД обслуживает все запросы (read + write)

### Какие элементы системы кешировать

| Элемент | Обоснование | Приоритет |
|---------|-------------|-----------|
| **Список заказов в MES** | Главная проблема, частые запросы с фильтрами | Высокий |
| **Статусы заказов** | Редко меняются, часто запрашиваются | Средний |
| **Информация о заказе (детали)** | Можно кешировать на короткое время | Низкий |

### Проблемы, которые решит кеширование

1. **Скорость загрузки дашборда** - из кеша вместо БД
2. **Снижение нагрузки на БД** - меньше запросов
3. **Масштабируемость** - готовность к росту нагрузки

---

## 2. Предлагаемое решение

### Выбор типа кеширования: Серверное

**Почему серверное, а не клиентское?**

| Критерий | Клиентское | Серверное | Выбор |
|----------|------------|-----------|-------|
| Свежесть данных | Сложно инвалидировать | Централизованная инвалидация | Серверное |
| Множество клиентов | Каждый кеширует отдельно | Общий кеш для всех | Серверное |
| Контроль | На стороне клиента | Полный контроль | Серверное |
| Сложность | Просто (HTTP headers) | Требует инфраструктуры | Клиентское |

**Вывод:** Серверное кеширование, потому что:
- Множество операторов запрашивают одни и те же списки заказов
- Нужна быстрая инвалидация при изменении статуса заказа
- Централизованное управление TTL и стратегией

### Выбор паттерна: Cache-Aside

#### Сравнение паттернов

| Паттерн | Описание | Плюсы | Минусы |
|---------|----------|-------|--------|
| **Cache-Aside** | Приложение управляет кешем: проверяет кеш → если нет, читает из БД → кладет в кеш | Простота, контроль, read-heavy оптимизация | Код в приложении, риск stale data |
| **Write-Through** | Запись сначала в кеш, потом в БД | Кеш всегда актуален | Задержка записи, сложнее реализация |
| **Write-Behind** | Запись в кеш, асинхронно в БД | Быстрая запись | Риск потери данных |
| **Refresh-Ahead** | Фоновое обновление до истечения TTL | Нет cache miss | Сложность, лишние запросы |

#### Почему Cache-Aside

1. **Read-heavy нагрузка** - операторы читают список заказов гораздо чаще, чем он обновляется
2. **Простота реализации** - команда может быстро внедрить
3. **Гибкость** - полный контроль над логикой кеширования
4. **Подходит для списков** - хорошо работает с пагинированными данными

#### Почему НЕ другие паттерны

| Паттерн | Причина отказа |
|---------|----------------|
| Write-Through | Избыточен для read-heavy, усложняет write path |
| Write-Behind | Риск потери данных при сбое, неприемлемо для заказов |
| Refresh-Ahead | Сложно предсказать, какие страницы будут запрошены |

### Архитектура решения

```
[MES Frontend]
      │
      ▼
[MES API (C#)]
      │
      ├──────────────────┐
      │                  │
      ▼                  ▼
[Redis Cache]      [MES Database]
(список заказов)   (PostgreSQL)
```

### Технология кеширования

**Redis** (Yandex Managed Redis)

| Критерий | Значение |
|----------|----------|
| Тип | In-memory key-value store |
| Persistence | RDB + AOF (для надежности) |
| Cluster | Single node для начала, cluster при росте |
| Eviction | allkeys-lru |

---

## 3. Диаграмма последовательности

### Операция чтения: Получение списка заказов

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  MES        │     │  MES API    │     │   Redis     │     │  MES DB     │
│  Frontend   │     │             │     │   Cache     │     │ (PostgreSQL)│
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       │                   │                   │                   │
       │ 1. GET /orders    │                   │                   │
       │   ?status=NEW     │                   │                   │
       │   &page=1         │                   │                   │
       │──────────────────>│                   │                   │
       │                   │                   │                   │
       │                   │ 2. GET            │                   │
       │                   │ orders:NEW:page1  │                   │
       │                   │──────────────────>│                   │
       │                   │                   │                   │
       │                   │   ┌───────────────┴───────────────┐   │
       │                   │   │ Cache HIT?                    │   │
       │                   │   └───────────────┬───────────────┘   │
       │                   │                   │                   │
       │                   │ 3a. [HIT] Return  │                   │
       │                   │    cached data    │                   │
       │                   │<──────────────────│                   │
       │                   │                   │                   │
       │                   │         OR        │                   │
       │                   │                   │                   │
       │                   │ 3b. [MISS] null   │                   │
       │                   │<──────────────────│                   │
       │                   │                   │                   │
       │                   │ 4. SELECT * FROM  │                   │
       │                   │    orders WHERE   │                   │
       │                   │    status='NEW'   │                   │
       │                   │    LIMIT 20       │                   │
       │                   │───────────────────────────────────────>│
       │                   │                   │                   │
       │                   │ 5. Return orders  │                   │
       │                   │<───────────────────────────────────────│
       │                   │                   │                   │
       │                   │ 6. SET            │                   │
       │                   │ orders:NEW:page1  │                   │
       │                   │ TTL 60s           │                   │
       │                   │──────────────────>│                   │
       │                   │                   │                   │
       │ 7. Return orders  │                   │                   │
       │<──────────────────│                   │                   │
       │                   │                   │                   │
```

### Операция записи: Изменение статуса заказа

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  MES        │     │  MES API    │     │   Redis     │     │  MES DB     │
│  Frontend   │     │             │     │   Cache     │     │ (PostgreSQL)│
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       │                   │                   │                   │
       │ 1. PUT /orders/   │                   │                   │
       │   ORD-123/status  │                   │                   │
       │   {status:        │                   │                   │
       │    "IN_PROGRESS"} │                   │                   │
       │──────────────────>│                   │                   │
       │                   │                   │                   │
       │                   │ 2. UPDATE orders  │                   │
       │                   │    SET status=    │                   │
       │                   │    'IN_PROGRESS'  │                   │
       │                   │    WHERE id=      │                   │
       │                   │    'ORD-123'      │                   │
       │                   │───────────────────────────────────────>│
       │                   │                   │                   │
       │                   │ 3. OK (1 row)     │                   │
       │                   │<───────────────────────────────────────│
       │                   │                   │                   │
       │                   │ 4. DEL orders:*   │                   │
       │                   │    (invalidate    │                   │
       │                   │     pattern)      │                   │
       │                   │──────────────────>│                   │
       │                   │                   │                   │
       │                   │ 5. OK             │                   │
       │                   │<──────────────────│                   │
       │                   │                   │                   │
       │ 6. 200 OK         │                   │                   │
       │<──────────────────│                   │                   │
       │                   │                   │                   │
```

### Диаграмма в draw.io

Ссылка на диаграмму: `Task5/sequence_caching.drawio`

---

## 4. Стратегия инвалидации кеша

### Сравнение стратегий

| Стратегия | Описание | Плюсы | Минусы |
|-----------|----------|-------|--------|
| **TTL (Time-based)** | Данные истекают через N секунд | Просто, автоматически | Stale data до истечения |
| **Event-based** | Инвалидация при изменении | Всегда актуально | Сложнее реализация |
| **Manual** | Программная инвалидация | Полный контроль | Нужно не забыть |
| **Hybrid (TTL + Event)** | TTL + инвалидация на событие | Баланс | Средняя сложность |

### Выбранная стратегия: Hybrid (TTL + Event-based)

**Реализация:**

1. **TTL = 60 секунд** для списка заказов
   - Даже без инвалидации данные обновятся через минуту
   - Защита от "вечного" stale cache

2. **Event-based инвалидация** при изменении:
   - Создание заказа → инвалидация `orders:NEW:*`
   - Изменение статуса → инвалидация `orders:{old_status}:*` и `orders:{new_status}:*`
   - Удаление заказа → инвалидация всех связанных ключей

### Почему Hybrid лучше остальных

| Стратегия | Причина отказа |
|-----------|----------------|
| Только TTL | При изменении статуса операторы могут не увидеть заказ до минуты |
| Только Event | Если пропустим событие, кеш будет навсегда stale |
| Manual | Легко забыть инвалидировать при рефакторинге |

### Схема ключей кеша

```
orders:{status}:page{N}  - список заказов по статусу и странице
orders:{status}:count    - количество заказов со статусом
order:{order_id}         - детали конкретного заказа
```

**Примеры:**
- `orders:NEW:page1` - первая страница новых заказов
- `orders:IN_PROGRESS:page2` - вторая страница заказов в работе
- `order:ORD-12345` - детали заказа

### Паттерн инвалидации

```csharp
// При изменении статуса заказа
public async Task UpdateOrderStatus(string orderId, string newStatus)
{
    var oldStatus = await GetOrderStatus(orderId);

    // 1. Обновляем в БД
    await _database.UpdateOrderStatus(orderId, newStatus);

    // 2. Инвалидируем кеш
    await _cache.DeleteByPattern($"orders:{oldStatus}:*");
    await _cache.DeleteByPattern($"orders:{newStatus}:*");
    await _cache.Delete($"order:{orderId}");
}
```

---

## 5. Дополнительное задание: Сравнение решений

### Решение 1: Redis Cache-Aside (рекомендуемое)

**Описание:**
- Отдельный Redis сервер
- Cache-Aside паттерн
- TTL + Event-based инвалидация

**Диаграмма:**
```
[MES API] ──check──> [Redis] ──miss──> [PostgreSQL]
                        │
                    <───hit
```

**Плюсы:**
- Простота внедрения
- Хорошо понятен команде
- Гибкость в управлении кешем
- Надежность (Redis persistence)

**Минусы:**
- Дополнительная инфраструктура
- Код инвалидации в приложении
- Потенциальный cache miss при cold start

### Решение 2: PostgreSQL Materialized View + REFRESH

**Описание:**
- Materialized view для списка заказов по статусам
- Периодический REFRESH (каждые 30 сек)
- Без дополнительной инфраструктуры

**Диаграмма:**
```
[MES API] ──────> [Materialized View] <──refresh── [Scheduler]
                         │
                   [PostgreSQL]
```

**Плюсы:**
- Нет дополнительной инфраструктуры
- Данные всегда консистентны с БД
- SQL-based, понятно DBA

**Минусы:**
- REFRESH блокирует view
- Не такой быстрый как Redis (все еще диск)
- Сложнее с пагинацией
- Данные не совсем realtime (задержка refresh)

### Сравнительная таблица

| Критерий | Redis Cache-Aside | Materialized View |
|----------|-------------------|-------------------|
| **Latency** | ~1ms (memory) | ~10-50ms (disk) |
| **Свежесть данных** | Event + 60s TTL | 30s refresh interval |
| **Инфраструктура** | +Redis | Только PostgreSQL |
| **Сложность кода** | Средняя | Низкая |
| **Масштабируемость** | Высокая (Redis Cluster) | Ограниченная (один PG) |
| **Стоимость** | +Redis instance | Без доп. затрат |

### Заключение

**Рекомендуется Решение 1 (Redis Cache-Aside)** по следующим причинам:

1. **Производительность** - latency критична для UX операторов
2. **Масштабируемость** - с ростом нагрузки Redis легко масштабировать
3. **Гибкость** - контроль над TTL и инвалидацией
4. **Экосистема** - Redis используется повсеместно, много документации

Решение 2 подойдет как **временная мера** или если бюджет на инфраструктуру ограничен.

---

## 6. План внедрения

| Этап | Задачи | Срок |
|------|--------|------|
| **1** | Развернуть Yandex Managed Redis | День 1 |
| **2** | Добавить Redis client в MES API | День 2-3 |
| **3** | Реализовать Cache-Aside для GET /orders | День 4-5 |
| **4** | Реализовать инвалидацию при изменении статуса | День 6-7 |
| **5** | Нагрузочное тестирование | День 8 |
| **6** | Деплой на staging, тестирование | День 9-10 |
| **7** | Деплой на production | День 11 |
| **8** | Мониторинг cache hit rate | Ongoing |

---

## 7. Метрики успеха

| Метрика | До | После (ожидание) |
|---------|-----|------------------|
| Время загрузки списка заказов (p95) | > 5 сек | < 200 мс |
| Cache hit rate | - | > 80% |
| Нагрузка на БД (queries/sec для списка) | 100% | < 20% |
| Жалобы операторов на скорость | Много | 0 |
